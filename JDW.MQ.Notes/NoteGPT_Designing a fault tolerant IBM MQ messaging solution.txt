
00:00:01
hi I'm David we're let's look at how you build a truly fault tolerant and scalable MQ messaging solution it's quite simple really the principle is very simple you want to move from the left to the right the left-hand side we have a single entity something but with highly dependent on and if we look at its availability it directly impacts what we can do while that's not available nothing is available whereas on the right we don't have a single entity we have multiple entities now with multiple entities that means any particular problem with any one of those does not impact the entire system greatly reducing the impact greatly increasing the overall availability of your solution and is that fundamental principle that you then need to apply to your mq solution it's not just availability though it also helps for scalability from a scalable point of


00:01:01
view then if you have a system of a certain size you can you can fill that to a certain level and if I want to get more scale out of it maybe I can grow that maybe I can vertically increase the size of it and I'll get to a certain level of that but I'm optimally gonna have to hit a level where I can't go any further physical sizes are constrained whereas if I go the horizontal route and I scale horizontally then I can move from having a single thing to multiple individual things which all process that same work and therefore I can continue to scale pass the limits of an individual system and increase the scalability further and further as I need it and we don't have to stop there we can continue going as far as realistically you need if those separate entities truly are independent so let's add some basic principles let's move back into IBM MQ


00:02:03
let's look at what does that mean from an MQ queue manager deployment point of view so here we have a single lonely queue manager it's just sat there on its own now that's on a particular node it's on a system you know could be a machine could be a virtual machine could be a container who really knows the point is it's a single thing it's running on its own now with that I've been have an application application connected to it and this is the first point where we start to look at what does it mean from an availability point of view before we even get into how do I make that queue manager that MQ deployment more highly available let's first mention from an application point of view you really do need to take that into account first you need to look at the application and think okay then how can I improve the availability of this application perhaps I could have multiple instances of a application maybe I could have them all running concurrently and if I have any particular failure on any of those instances I still have remaining


00:03:04
instances to carry on that workload so that's the first thing you look at your applications then we look at the infrastructure and like I said this is a very very simple setup I've got a single queue manager no high availability nothing set in place to recover back you manager in the event of a problem so if you then look at the I've split into system availability and message availability so system availability means is the messaging system is MQ available can applications connect to it and process work or submit new works new messages message availability is looking at the individual messages MQ provides queuing for messages and with that that means you need to be able to get back and access to those messages and during a problem when a commander isn't available those messages will not be available so if we look at the availability you can see we go easily from 100% available while the commander's running once McCue manager


00:04:05
is unavailable maybe you've brought it down for maintenance maybe you had a problem of a node or a problem with the queue manager at that point nothing is available you're down to zero percent availability and because I've got no automated process in place here to bring that queue manager back on line I've got no backup node they're ready to take over it's going to take you a considerable period of time to get that system back online you know possibly indefinitely if you have a terminal failure of that node then the same goes for the message availability while that queue manager is not running you cannot access any of the messages but we're already queued in to that queue manager so pretty much this is the system which gives you very very low availability so what do we do next well the first thing to do is to bring in extra nodes to the backup system via systems where that humanity could be running on and that those nodes are there as a way to be able to take over in the event of a problem with the node


00:05:08
where the queue manager is active or a problem with the queue manager itself now there's multiple ways you can do this with MQ I'm not going to go into details of them here I'll put some links in the video we've got multiple solutions we've got replicated data Q managers which gives you a very nice direct data replication between three nodes in an H a quorum we've got MQ appliances for give you a way of replicating data between physical boxes we've got other storage based solutions like multi instance key managers H a clusters there are multiple ways that you can provide this sort of redundancy and resilience into an MQ system so let's assume that is in place now at that point we haven't fundamentally changed the fact that I've still got one Q manager but what we have changed is the speed that you can give our Q manager back online and if I can get it back online quickly because I've got a an H a system there monitoring ready to take over ready to detect a failure and ready to bring that key mojo


00:06:08
back up and running then at that point I can be up and running and processing my applications processing my queued messages very very quickly and depending on which technology you want to use the Mac could be anything from sort of sub-second to do a restart of a queue manager and ported over to another node safer maintenance to a few seconds depending on what that queue manager is doing at the time so it's a pretty fast and efficient way of bringing that queue manager back on line making it allowing me out to connect back in again and also them getting access to those messages however we have still got one queue manager in this picture so that system availability message availability goes from a hundred percent right down to zero percent because while it's doing that quick failover you still don't have any queue managers running but I can then process any messages off so that takes us to a deployment like this this deployment if you look at the details you can see I've


00:07:09
now got three distinct queue managers four got queue manager 1 Q 2 and Q major 3 now the key thing here is they may be distinct as in they are separate queue manager x' with their own high availability you can see with a available they've got and standby instances replication happening across the other two nodes but because they are effectively providing the same service the same set of queues the same ability for applications connect into I can distribute my application workload across those three different queue managers and therefore I can distribute the risk as well so if we look at the availability here then you're gonna see that actually any one failure does not take out the entire system now specifically if you look at the availability it depends because it depends on what those applications are doing on what their requirements are and this is one of the subtleties in approach like this this active active


00:08:09
deployment style so let's look at a situation where these applications have a certain level of affinity now what does that mean well each queue manager has it may look the same as the other key managers but if I put a message on to that a queue on that queue manager say on queue manager 1 that message only exists on queue manager one it doesn't exist on queue manager 2 or 3 it may be replicating across nodes a B and C but is it currently only available on queue manager 1 which means maybe I've got strict ordering requirements maybe I've got a request reply slow and I need to get back to a particular place to get the reply message back at that point my applications might have some affinity burnt into them here what we've done is okay we've got an application which has maybe got nine instances for availability but we have tied three each of them to each of the three different key managers and that's quite simple all you have to do is when I connect I am connecting to a specific commands are still so that's quite close


00:09:11
to the sort of the single queue management model but if you then look at the availability my difference here is if one of those queue managers becomes unavailable you're not taking everything down to zero percent availability you're only taking it down to two-thirds availability because the other two key managers carry on running which means two-thirds of those applications can carry on running unaffected completely they don't see any problem and is only a subset of your application instances which are actually impacted by any outage so that's pretty good that gives you pretty good availability and now I can start to think well maybe I don't have to worry so much about each individual queue manager to take it the next step of availability at that point we need to look at situations where you've got no affinity with no affinity then it means these applications are able to connect into any one of those key managers they don't worry which one they're connected to they might come into queue manager one one second but then they might come into commander two


00:10:11
another second so with that that's more than sort of I'm taking random messages off of queues on processing them I'm sending them on their way I don't really mind which instance of a queue on consuming from or producing - now that allows us to increase the availability even further if we look here the message availability stays the same because when one of those queue managers goes down then a third of those messages are potentially locked away until vacuumed and comes back up again a couple of seconds later but the system availability has now been increased to 100% it's always available because none of the application instances are tied exclusively to one of those queue managers which means if they're connected say to key module one and commander one is shut down those applications can instantly reconnect to any of the other applicators and not worry about which one they're connected to so from our point of view my system availability stays 100% all times and we've got a few nice tricks with mq and capabilities to make


00:11:12
it easy for you to write those applications and make those deployments so is it a case of never go back you just go for that last scenario you just go with that well it's not quite as simple as bad you know hopefully you can see going to multiple queue manager approach is a lot nicer from an availability point of view single key manager I've still got to worry that actually at some point my system goes down to zero availability so it's not as good from an availability point of view however it is quite nice and simple it's simple from an application point of view the application doesn't have to think oh I've got multiple distinct partitions on that queue and therefore I've got to worry which one I connected to so if I've got any of those limitations I mentioned like affinity then I do have to consider that from an application point of view but then there's all these downside so the fact that if it goes offline then what am i applications do from a scaling point of view I can only take it so far whereas if you look on


00:12:14
the right multiple queue managers are working together then that'll give you the greatest level availability and the greater the level of scalability as well but you do have to think about your application slightly differently you have to build in that model into the applications right from the start so ideally you can stop thinking about an individual queue manager rather than thinking of an individual queue manager each time you're looking at a highly available system really do consider how I can build that into multiple queue managers now I'm not saying you can do that for every single pattern as we've just discussed but at least consider that as a starting point because the best way to think about it is as a single thing which is a group of key managers and with a group of key managers if I can apply that from an application point of view then I am going to get the highest availability and scalability out of your MQ system now I'll also point you to a new


00:13:15
capability which we've had in MQ for a few months now called a uniform cluster now uniform cluster is a new way of building these multi queue manager deployments to ensure that your applications are evenly distributed across all of those key managers automatically balanced and see how that goes into the future at that point I'll stop and I'll put some links below and so you can go find more information thank you

