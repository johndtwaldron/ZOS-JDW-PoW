
00:00:00
hi my name's David Ware I'm going to be talking to you about ibmq's published subscribe features specifically about using publish subscribe in nmq network so that's a connected set of mqq managers if you're not familiar with mq's post subscribe features I have another session that's also on YouTube which goes into as an introduction about the various features of publish subscribe so find a link below this presentation and that will take you to it but for this session what are we going to do we're going to look at the basic concepts of joining queue managers together to do publish subscribe what are the various possible topologies that are available to you then we're going to compare and contrast them to see which ones suit which scenarios and what are the pros and cons for each of them and then finally we're going to look at some actual scenarios just to put it into perspective [Music] so first off we can consider doing publish subscribe


00:01:00
on a single key manager in this situation we have all the Publishers connected to the key manager and all the subscriptions defined on the same key manager in that instance it's very simple for a queue manager to know where to deliver messages to you publish a message and using mq's inbuilt topic tree structures it can match it to subscriptions and deliver a copy of each message to each subscription but in a distributed environment where you have multiple key managers and some of your Publishers are connected to some key managers and some of your subscriptions on other key managers you want to be able to publish on one key manager and have mq automatically work out where it needs to send the messages to to where the subscriptions are connected and deliver those message to them in a reliable efficient manner you also want to be able to do that in a way that the applications don't need to know where the subscriptions are when they're publishing and also ideally from an Administration point of view you don't want to have to fine-tune the configuration to specify exactly where


00:02:02
all the subscriptions are you want to leave that to mq to sort out for you so what options are available to you well there's a couple of main topologies one is a hierarchy will you join multiple key managers together alternatively you can use mq clusters where you Federate queue managers so that they can become aware of other key managers in the environment automatically connect to them and do Publishers subscribe across those in both cases you need to do some configuration to get the assistant set up so we'll start with configuration and then move on from there foreign hierarchy this is something that mq has supported right from the very start when it provided publish subscribe many years ago it's a way of manually defining connections between specific queue managers to say that they are related for publish subscribe


00:03:05
the actual configuration is very simple all you have to do is go to each key manager and say which is its parent key manager I.E the key manager above it in my hierarchy so every key manager here you'd have to alter its parent value to the name of a queue manager above it all apart from a queue manager right at the top who obviously has no parent these key managers will then talk to its parent to communicate who they are and negotiate a conversation between them to do that they need to have Channel connectivity so you either have to have manually defined channels between these queue managers or you could be within an mq cluster and those queue managers can learn about each other because it has to do that communication asynchronously once you've altered your Q manager to specify a parent it's best to establish that the communication has succeeded so to do that if you do display Pub sub on a key manager you can


00:04:06
list all of its relationships so if you do that on any of these key managers you should see who its parent queue manager is and also if it has any children Q managers associated with it you can also check your mq error logs to make sure that the communication is successfully completed once you've got this set up you'll see in a minute how Publications can flow from any queue manager to any other queue manager in the hierarchy and this is the default Behavior so as soon as you create a subscription on a key manager within a hierarchy any other queue manager where you publish will automatically send the messages to it you can if you want scope down parts of your topic tree to say actually for these particular topic strings I don't want to share my subscriptions or share my Publications with other queue managers and that's the subscription scope and publication scope which you can modify on the topic objects within the topic tree once you have this set up as you can see


00:05:11
messages will flow from the publishing queue managers with one of the yellow one on the right via its direct relationships through to the queue managers where the subscriptions exist it doesn't flow directly from the publishing queue manager to the subscribing queue managers it has to follow the route within the hierarchy definitions so let's look at clusters again clusters we have to do a configuration step to establish the fact that you want to do publish subscribe between the key managers it's not just good enough for key managers to be within the same mq cluster to be able to do publish subscribe although to start with you don't have to worry about the channel connectivity like you do for a hierarchy because any queue manager within a cluster can automatically learn about any other queue manager in the cluster find out where it exists create channels to it and send messages to it so that side is covered so instead you have to do an additional step to make sure that when you publish on


00:06:13
certain topics they will flow through to the subscriptions on other key managers you do that by defining a topic object you define a topic object you associate it with the branch of your topic Tree in your system that you want to be shared across all the key managers in the cluster and just like for a clustered queue you then specify a cluster name for that topic object so here we Define a topic object we give it a name fruit object we go to topic string of price fruit and then we associate it with cluster one by doing this the key manager which you define it on obviously is aware that that branch of atopic tree is clustered also it will send that information up to the full repositories within your cluster and they will then pass that information out to all the other members of the cluster so now as soon as you define it every key manager in the cluster becomes aware of the fruitops definition and aware that it's clustered so everybody


00:07:14
in the cluster now immediately knows that any subscriptions that exist need to be known across the cluster and any Publications that need to be published might be being subscribed to elsewhere in that cluster so that's the equivalent of joining the Q managers together in the hierarchy apart from you're only doing it for a branch of the tree rather than the whole topic tree we saw over hierarchy we we send the messages via every Q every direct relationship in the cut in the hierarchy so we go up and down the tree clusters we have two different routing mechanisms we have the direct mechanism which we've had since mq version 7 um continue through version 8 and Beyond this is where when you have Publishers on some key managers and subscribers elsewhere the publishing queue managers connect create channels directly to the key managers where the subscriptions are and send the messages directly to them and onto the subscriptions


00:08:17
so that's the direct routing mechanism in version 8 we introduce a new mechanism which you can choose to use you can still use for direct mechanism if you wish but we have the topic host mechanism the topic host mechanism you control this by a new attribute on a topic object so the object that you cluster you can now set the CL root whether it's direct or topic host if you set it into topic host where you define that topic object which happens to be on the Queue manager in the middle in this example this is where we're going to root the messages via so the publishing queue manager Roots the message into the queue manager where you defined it and from there vacuum manager forwards it on to the key managers where the subscriptions are now this is obviously a more indirect route but it does have its benefits in some situations so which is best well as you can probably guess one size does not fit all it really depends on many many different factors within publish subscribe to


00:09:24
actually decide on the best situation for you the best solution for you and to do that I think you need to understand a little bit more about how it works under the covers so that you can understand what your system will be doing in the different environments and from there hopefully we can make the right decision as to which solution to use for your topology so if we look at the mechanics I've been talking up until this point about sending Publications from Key managers um to the key managers where the subscriptions are but how does mq know that it doesn't just send the Publications out to every Q manager that it knows about in the hope that there are subscriptions there it actually relies on a mechanism called subscription propagation so when a subscription is created on a key manager for a particular topic string if that queue manager is in a hierarchy or it's for a clustered topic or at some


00:10:24
point below um in the topic tree where you've clustered it knows that that information needs to go elsewhere in its topology it needs to be sent to other queue managers so that those key managers know that this queue manager is interested now in those Publications so first time it sees a subscription for a particular topic string it builds a thing called a proxy subscription it's really just a message which is going to send out to other key managers so it builds that proxy subscription message and sends it across mq channels point to point to the other queue manager that needs to the other key managers depends on which topology we're looking at and we'll look at that in a second but for now we've just got the key manager on the left so we've sent that to the proxy subscription information vacuum manager will create itself a subscription of a special type called a proxy subscription and it's really just a subscription for a particular topic string and it's pointing back to the queue manager where it came from


00:11:30
this will result in Publications which match it being sent back to where the subscription actually exists so if a publisher comes along and publishes a message vacuum manager will match it against any subscriptions it knows about it'll match it to any of the local subscriptions and give them a copy of a message it'll also match it to this proxy subscription realize that it's being sent to a different queue manager get the correct channel for that queue manager and send a copy of a message to it on arrival over queue manager which originated with proxy subscription it will process it again looking for any subscriptions it knows about in this case it knows about the local subscription so it delivers back copy of a message to that local subscription if you have multiple subscriptions for a particular topic screen it doesn't need to flow a second proxy subscription


00:12:32
because the proxy subscription is really just saying that vacuum manager is interested in most Publications not why it's interested or who it's interested for so here now we can publish a message one copy of the message will flow across the channels and one arrival two copies will be reduced and delivered onto the two separate subscriptions so this is the general mechanism but we're going to use for all the different topologies I've already talked about and it really depends how you've wired the key manager together as to how we send the proxy subscriptions or where we send the proxy subscriptions so if we look at a hierarchy and we Define ourselves a subscription down the bottom we need to make sure that you can publish on any Q manager in this hierarchy and get a message back to it and it has to flow following the connectivity of those queue managers in the hierarchy so only via the direct relations so when you create the subscription in a hierarchy it'll generate a proxy


00:13:33
subscription and it'll send it to the direct relations in this case it only had a parent on that bottom right hand queue manager when that queue manager receives it it also generates a proxy subscription and sends it on to any of its direct relations that it hasn't already sent proxy information out to so in this case it's going to send it out to those queue managers and then they're going to do the same and send it out to the other queue managers until eventually the proxy subscription information is fed out to all the far reaches of this hierarchy if a second subscription came along and another key manager it would do the same thing it would generate a proxy subscription and send it out to the direct relations now when it arrives at the next queue manager that one's already sent out proxy subscriptions to certain places in the hierarchy so it only has to fill in the gaps right so now we have two subscriptions in place and we have proxy subscriptions that have flowed around the entire hierarchy which means a publisher can come in on any key manager


00:14:39
and publish a message then by publishing the message we can follow the trail of proxy subscriptions all the way back to where the subscriptions exist and then deliver the message to the actual subscriptions that actually need the messages so that's how it works in a hierarchy now in a cluster now this depends on which routing mechanism you're using so if we first look at the direct mechanism foreign we're going to send proxy subscriptions from any queue manager where you create a subscription through to every other queue manager so that they know who needs the messages and how they need to connect to and send the messages back to do that when you define your cluster topic object that gets sent out to every queue manager in the cluster as well as being told about a topic object as we saw before and knowing that now this branch of a topic tree is clustered each queue manager has to become aware


00:15:42
of every other key manager in the cluster because it needs to have the capability of being able to send proxy subscription out to anybody else that might need it so when a subscription comes along on a queue manager this time it's queue manager on the left it knows it's in a cluster it knows that the subscription is to a topic string which is being clustered so one below the cluster topic object and at that point it builds proxy subscriptions and it'll send it out to all the other members of the cluster it does that by creating cluster sender channels to all those queue managers and then sending the proxy information across two of them then another subscription comes along it'll do exactly the same so this is how we get the proxy subscription out to all the other key managers in the cluster when you're doing direct routing this means when a publisher comes along over on the top right when you publish it has two proxy subscriptions on that local key manager


00:16:46
each pointing directly to the two key managers whether subscriptions have been defined so vacuum manager can again create cluster sender channels to those queue managers and send the messages directly to them and onto the subscriptions so you get quite a flow of proxy information and quite a number of channels but you get very direct flowing of Publications the topic object it's been drawn sort of floating between any key managers the reason being is when you're doing direct routing it really doesn't matter which Q manager you define your topic object on because as we've seen the information gets sent out to everybody and everybody acts exactly the same way whether they've created the topic object or someone else created it in the cluster so you just need to Define it once and you just need to pick a queue manager to Define it on if you're looking for a place to Define it then something like a full repository queue manager might be a suitable queue manager because those key managers tend to stay in the cluster for a long time


00:17:49
therefore there's no risk that the key manager which you define it on drops out of the cluster because if it does drop out of a cluster then it'll lose the information that topic has been clustered so that's for direct routing let's look at topic host routing in this situation because we're going to be routing via the queue manage where you define the topic we're not going to have to share the proxy subscription information as widely so when we Define our topic object this time it becomes very important that you pick a specific queue manager to do it because all the Publications are going to go through this particular key manager so it needs to be able to handle a load it needs to have good availability to make sure that it can be processing the messages continually it also really needs to be able separate from say a full repository key managers we always recommend full repository key managers in a cluster don't do application Level traffic so in this situation you don't want to make a full


00:18:54
repository a host of your topic because that would mean all the application Publications start flowing through full repository queue managers right so what happens when we Define that object well we Define the object as we did before this is a topic host rooted one the topic object itself still gets sent out to every queue manager in the cluster but not every key manager gets told about every other queue manager it doesn't need to because it's not going to contact them instead each key manager just gets told about the queue manager that hosted the particular topic object all apart from the key manager that actually hosts the topic object this one is actually going to be told about everybody else it needs to do that because there are some error situations where it may have to rebuild its information or confirm its information about other queue managers in which case it needs to know about everybody but when a subscription comes along we're going to build a proxy subscription just as we did before but instead of sending it out to everybody creating channels and sending it to


00:19:59
everybody as we did in a direct case so the topic host routing all we have to do is send it to the queue manager where we've actually defined the topic because that's where the messages are going to come from once it arrives on vacuum manager it doesn't go any further it just stays on that single queue manager where you've defined the topic object similarly we create a description down the bottom it's going to do the same it's going to create a channel and send the proxy subscription information so this is good because we haven't sent much information about we haven't had to create many channels however it does pose a problem when a publisher comes along to another key manager and publishes a message it can publish it to a topic string under the clustered branch and it knows it's been clustered but it doesn't know about any proxy subscription information so it doesn't know where to send the message to so in that situation all it does is take the message and always sends it on to the queue manager where the topic has


00:21:00
been defined so this is for a topic host rooted topic so it creates itself a channel and sends the message on when it arrives at vacuum manager a bit like it was in a hierarchy when it arrives it knows about the proxy subscriptions for the two key managers whether subscriptions are creates the channels and sends the messages onto those two key managers so we've ended up with the same end result the messages have ended up over two correct queue managers with a subscriptions it's just gone via that Q manager in the Middle where we Define the topic object so let's do the side by side part let's compare these different solutions good parts and bad parts so let's look at scaling hierarchies and topic hosts clusters these are quite good from a channel connectivity point of view because you've created this you've defined exactly who talks to who in the hierarchy you know exactly who's talking to who hematopic host routing you know


00:22:02
that everyone is going to connecting in only to vacuum manager whoever topic host is defined so in a very large system where you have lots and lots of queue managers you can scope down who needs to talk to who or in a system where you need to control the connectivity direct clusters on the other hand fat can be a concern if it's a particularly large cluster you know with hundreds possibly even thousands of plus Q managers in it then a direct cluster means the channels will connect between all the different queue managers probably unnecessarily because you're probably not publishing or subscribing on all of those key managers another aspect of scaling can be considered the frequency that you create and delete subscriptions if you're continually creating and deleting subscriptions we have to flow the proxy subscription around with hierarchies and direct clusters that proxy subscription information flows to all the different queue managers eventually in the system whereas on the topic host cluster routing it just sends it into the key manager where you've defined the topic host so that's another aspect of scaling that


00:23:07
can be considered what about the publication flows themselves well if you look at the direct cluster that's a nice efficient mechanism because there's at most one hop between the Publishers and the subscribers obviously putting the Publishers and subscribers on the same queue manager is even better but at the very least you are only one channel hop away from a publishing queue manager to a subscribing queue manager so that's nice and direct as you'd expect for hierarchies and topic host clusters you've got potentially multiple hops a hiri hierarchy sorry wherever you however you define it that's going to dictate the maximum number of hops a topic host cluster that's going to be one or two hops the two hops being the maximum but in both those situations if performance and latency is important to you you can carefully architect Your solution to make sure that you minimize those hops so if we look at save a topic host cluster


00:24:08
we could realize that the publishing queue manager is where all the messages are coming from and instead of defining the topic host on that queue manager in the middle you could remove it from there and Define it on the actual queue manager with the publisher now in that situation you benefit from a proxy subscription information just being sent up to that key manager and the fact that you're now back to at most one hop between the publishing and the subscribing key managers you could do the same with a hierarchy if you were to say put the publishing queue manager as the root of the hierarchy so what about configuration well this really comes down to what what's your particular style what do you like hierarchies may need a lot of planning they're quite static they're quite hard to alter you can add key managers too but if you want to remove queue managers or remodel the hierarchy shape then you have to sort of tear it down and build it up again so that can be quite a lot of work clusters clusters are a bit more Dynamic obviously you can add and remove key manages into a cluster dynamically and if you do that they'll automatically


00:25:13
learn about the clustered topics and they'll learn about any proxy subscription information that they need to direct clusters are obviously simplest because you can just put your clustered topic anywhere you want and everybody is just going to go direct from from Publishers to subscribers topic host cluster routing that requires a little bit more thought because you've got to carefully plan where you're going to put those topic definitions availability now if we look at each one of these what happens if we lose a key manager if a key manager becomes unavailable for whatever reason whether it's planned or unplanned in a hierarchy if you take a queue manager outwards in the middle you're going to potentially be cutting Publishers off from the subscribers and you're not going to have any other way of getting those messages through to those subscribers until you bring that Q manager up again there's no alternative mechanism direct cluster if you take a queue manager out obviously vacuum manager is no longer going to be working so if that's got Publishers or subscribers on it you're going to have a potential problem but any other key managers they're not going


00:26:17
to be affected at all because they're just going direct from a publisher to the subscribers so availability isn't such a big concern though topic host routing you're back to a similar situation as you are with a hierarchy in the a particular queue manager now is very important to the flow of Publications so if you take the key manager out which is the topic host then you're going to stop Publications getting through from Publishers all the way to subscribers so that is a similar issue to hierarchies however we can avoid that from atopic host routing because unlike with a hierarchy where you can only have one possible route um in the hierarchy between queue managers for topic host routing we can do a similar thing to we do with cues for a queue in a cluster you can Define it on multiple key managers the same name the same configuration and we will workload balance messages across those multiple instances and we will route it to the available instances of a queue manager but as you might have imagined you can do the same for topics so if we Define


00:27:20
that topic host rooted topic definition now on two different queue managers the same configuration the same topic object name the same topic string now rather than just one of them learning about the proxy information both of them will be told about all the proxy information within the cluster so it's increased the proxy flow it's increased for connectivity slightly but it does mean now that we could send a publication to either one of those two key managers and equally be able to process the message and forward it on to where the subscriptions are so that's exactly what we do when we publish messages and we've got topic host definitions if there's more than one of them we will workload balance the messages across them when it arrives at each of them then that the key manager which it arrives at will send it out to all the subscriptions so message one goes to topic host a message two goes to Tommy goes B and so on


00:28:20
and this allows you to increase both the scalability so we've now got two routes for any of the messages so each individual queue manager is actually doing half the load of the system rather than the full load of the system which it was with a single definition so we can now horizontally scale out Publications as we increase the load also the availability problem if we take out one of those queue managers whether it's planned or unplanned the publishing queue manager will recognize the vacuum Andrew isn't available and it will send all future messages via the remaining queue managers in this case that top queue manager so messages will still flow through to the final subscriptions classes the downside of this particular approach is you're no longer maintain the relative order of those Publications because we're workload balancing messages across multiple different routes there's no guarantee that they're going to arrive in the same order that they're published in


00:29:24
if that's a problem then you can at least do take some steps to increase your scalability your your yes your scalability by defining different topic objects for different branches of the topic Tree on different key managers if you do that and we've got say all the fruit Publications going via one of the queue managers and all the vegetable Publications going via a different queue manager you're again separating out the load of the Publications across multiple different queue managers in different channels so that will at least reduce the load on any one single point in your cluster so let's look at a few scenarios just to make it clear exactly where the pros and the cons come into any solution so this is a big Hub and spoke cluster design this is a common pattern where you have many many queue managers which you might have a thousand or more key managers which are small queue managers may be


00:30:26
distributed around the globe maybe in the the back room of a of a Superstore or in a bank or something like that and then you've got headquarters where the headquarters can handle talking to everybody but everybody else can't handle talking to the individual other queue managers in the system I may never need to they never communicate directly with those key managers now if you want to do publish subscribe in a cluster such as that if you were to use a direct clustered topic and Define that as soon as you create a subscription on any queue manager it's going to communicate with all the other key managers in the cluster and suddenly you're going to have channels being created between all of your spoke queue managers around the edge which isn't a situation but it's been architected for so you don't want to use a direct cluster in this situation instead what you probably want to do is you want to use topic host routing you want to in this situation we brought in a new Bank of queue managers let's call


00:31:27
them the Gateway queue managers and that's where we're going to be routing all of our Publications and all of our subscription traffic through so whenever subscription gets defined it gets sent into those three new queue managers in the middle and whenever a publication gets sent out it'll always get sent to one of those three key managers and then from there on to where the subscriptions are so the connectivity model goes back very much to a hub and spoke style pattern if we look at another situation it's not as architected as the Hub and spoke pattern but it could be just as big say you've got a cluster which has got hundreds or a thousand Q managers within it and it's grown up into this over a period of time but it's not really one big system where everybody is talking to everybody else instead it could be a collection of many different applications spread across a handful each of different the different queue managers in the cluster so it's really just a cluster for simplifying Administration rather than using it for


00:32:32
connectivity now in the point-to-point world that works quite nicely because those key managers will only communicate with the ones that they need to talk to so only communicate to the key managers which host the queues that they're actually using never to everybody in their cluster but if one of those applications using saver three key managers on the right wanted to start using publish subscribe we will be back to the same problem we saw a minute ago which was if you use a direct cluster the key manager is where you define your subscriptions on are now going to start talking to everybody else we're going to start knowing about everybody they're going to start sending that information out to everybody else in the cluster which again is possibly not a good thing for this particular setup it's not how you scaled it how you designed it originally so what's the alternative well there's a number of Alternatives here possibly the the nicest solution is to create yourself a new small cluster


00:33:36
Define just for key managers which need to do public subscribe within that cluster you don't have to create new queue managers you're just creating a new cluster and making the existing queue managers that need to a member of that new cluster as well as their existing cluster once you have that new cluster in place Define your topic definition maybe it's a direct rooted topic on a queue manager within that cluster and specify that small cluster name rather than the big cluster name that way all the subscription traffic and all the publication traffic is going to be restricted to just the key managers that are members of the small cluster it's worth mentioning at this point that if you're in a situation where you don't want to um have the possibility the queue managers can Define themselves a clustered topic and possibly cause all this interaction to happen where you don't want it you can disable clustered Pub sub on Queue managers you can say PS class which is a


00:34:38
key manager attribute and set it to disabled it doesn't work by saying well I'm going to pick some queue measures to disable it on and others but I won't what you actually need to do is you really need to set it on the full repository queue managers in your cluster you set it in your full repository Key Management cluster that will prevent any clustered topic definition that they become aware of on a queue manager who might have accidentally defined it from being sent out to all the other key managers in the cluster so in this picture you would set it at least on the full repository key managers for the big cluster and not the four repository queue managers for the little cluster what other solutions could you use well you could use a hierarchy because it's only a small network of key managers just because you're in a cluster doesn't mean you have to use clustered Pub sub by defining a clustered topic object instead you could just Define a hierarchy and use and do and have the connectivity using that model and again in that situation you could set pscluster disabled for all key managers because none of them are


00:35:41
actually going to be defining clustered topics here or you could if you wanted use topic host routing within this system by doing that and setting it on a particular queue manager you're not risking every key manager that creates a subscription from communicating with every other Q manager in the cluster so you don't have that particular problem however it is possible a queue manager where you define the topic object is that might need to talk to everybody I said um earlier on but in some situations a key manager that's a topic host might have to communicate with the rest of the cluster just to reset its knowledge also it means you're defining that topic object within the cluster the large cluster therefore you have to have PS class enabled everywhere we've gone through hierarchies and cluster configurations now let's look at a couple of specific scenarios


00:36:45
first a very Dynamic setup if we have lots and lots of subscriptions coming and going very frequently and it could be many a second all done lots of different topic strings it could be a very Dynamic topic string stretch structure when this is happening and you're doing it across a set of key managers we happen to have three here in the middle maybe for availability or for loading for subscriptions across them if you do this then it presents a specific problem this is the fact that for those key managers to flow the proxy subscription around to keep each other up to date with who's subscribing to what and on what Q manager you might impose just as much load into the system for proxy subscriptions as the publication traffic itself and that can cause problems it might overload the channels it also might slow down to a point where the proxy subscriptions are being flowed at the wrong Point compared to when the


00:37:46
subscriptions exist so the queue managers effectively get behind in processing the proxy subscriptions and therefore the Publications don't flow correctly so what can you do about this situation you can switch from the subscription propagation model which we talked about earlier when we talked about flowing proxy Solutions around to a publication broadcast model now publication broadcast means we're going to send the Publications out to every queue manager just on the off chance where they have a subscription matching it if they don't then we've just wasted a trip of that publication but other than that no harm done so how do you do it you do it by setting a particular attribute on a topic it's called proxy sub so it's the proxy subscription attribute the default is first use which is the flowing proxy subscriptions around when you first use a particular topic string so that's what we've talked about up until this point but here if we set it to force that means at the time you configure the object that's when we're going to send a


00:38:49
proxy subscription out and we're actually going to send it out with a hash wildcard on the end of the topic string that the topic represents so here we've got a topic that's defined for the slash orders node in the topic tree if you set proxy sub to force put it in the cluster and we're going to send proxy subscriptions out from every queue manager to every other queue manager of Slash orders slash hash so bear in mind that it's not just where you define the object in a cluster it's on every queue manager in that cluster so as soon as you've done that we've now got these wild carded proxy subscriptions in place which means with the subscriptions we don't have to send out the individual proxy subscriptions for each individual topic string underneath the slash orders branch of a topic tree because when a publication comes in we're always going to have the two proxy subscriptions that match it the wildcarded ones that point to our two other key managers here so we're always going to send two copies of the message out at that point and then from there we're always going to send the messages on to any


00:39:55
subscriptions that happen to exist that match that particular topic so we don't have to send the individual subscriptions out it's worth pointing out that in version 8 we improved on this in that we cleaned up the mechanism for not sending out the additional proxy subscriptions there's more information in the notes foreign Ty this is a specific scenario which isn't really about moving Publications around the system to match subscriptions it's more about how do you make a subscription itself a single subscription highly available or at least continuously available we have this problem in point to point where we're sending messages from an application on one key manager to an application to a queue being processed by another application or another queue manager when we send those messages we send it in the cluster say via the transmission queue onto the queue manager where the


00:40:55
queue exists however if we were to have an outage on that queue manager those messages would simply build up some many solutions involve instead of having a single key manager where you define the queue in the cluster you have multiple key managers you define the same queue on both those queue managers you deploy your application to both of those queue managers to consume those messages and now we're going to workload balance for messages across them and we're going to root around failures so if we lose a queue manager all the messages are going to get rooted via the remaining available queue manager so this keeps your application continuously available for processing new messages so that's for point to point but really that application that pink application down the bottom that could just as easily be a subscribing application in a published subscribe world so how do you get the same behavior in publish subscribe many assume that the simple way to do that is we're in a cluster so we cluster the topic and


00:41:59
we create the subscription the same subscription on two different queue managers if we do that you expect to get the same behavior that you got for cues in fact what you get instead is those two subscriptions are seen as very two very different subscriptions and whenever you publish each message gets duplicated and sent out to each of those matching subscriptions and processed so you've now got two sets of each message being processed whereas actually what you wanted was one copy of the message being processed by either one of those two queue managers so that's not the solution you want to use here instead you really want to drop back to local British subscribe and point to point within the cluster so the first thing is you don't Define a topic as a clustered topic which is the obvious thing that you may consider doing instead you're not doing public subscribe on those bottom two key managers you're doing exactly the same as you did for


00:43:01
point to point where you're using two copies of a clustered queue to achieve workload balancing and routing around failures and your applications rather than being subscribing applications are going to be point-to-point consuming applications directly from the queue now we need to however we need to set up a subscription so that it matches messages being published on a particular topic so that's where we Define it on the Queue manager where the publisher is we don't Define it down where the applications consuming the messages are and instead of defining a subscription for a queue down um a simple queue associated with a subscription what we do is we Define a subscription on the top queue manager but we specify the cluster queue but we've defined the same on the two key managers down the bottom we don't specify a Target Q manager on that subscription we leave that for the cluster resolution logic to work out where to send the messages to and that's how we're going to achieve workload balancing and routing around the failures because when we publish a message we


00:44:06
match it to the local subscription which matches it to the cue that's associated with it which happens to be the clustered queue being a clustered queue it will resolve it to devote two bottom queue managers decide which one to send it to and send the message on workload balancing and routing around the failures one downside of this solution is if you've got Publishers that can come in on multiple different key managers because it's only a local subscription and we're not relying on clustered Pub sub you have to define the subscription on each of those key managers where the publisher is so they can each resolve down to where the subscriptions the subscription cues are finally a little bit a few hints and tips on when you're setting up such a system because when you set it up and you're going through those early stages it's quite easy to introduce problems or not


00:45:07
know what's going on hopefully this presentation has helped you understand a little bit more about what issue should expect to go on behind the scenes the problem determination helps you to diagnose where it hasn't worked correctly first thing to check always double check your configuration check what you've defined check your topic definitions checked your hierarchy relationships check your cluster configuration if you're in a cluster check each queue manager's knowledge of a cluster so this means you can go to any key manager in a cluster and display the cluster key managers that it knows about if you've defined yourself a direct clustered topic every queue manager should know about everybody else so check that they do if they don't then something's probably gone wrong and if you have defined a clustered topic check that it also is that is known by every queue manager in the cluster as well so you can do display T cluster for example on a key manager using runmqc and that will display the clustered topics that it's been told


00:46:09
about from the full repositories so that information should I get should have been sent to every key manager in version 8 we've also added a new attribute to a clustered topic object called cluster State this gives you some more information about possibly what's gone wrong it'll tell you that the information has been successfully sent up to the full repositories and sent out to the other queue managers or put an error as has occurred if you're in a hierarchy check the relationships like we saw at the start use display Pub sub and that will show you who your parents and who your children are always check the error logs in mq we'll write to each key manager thereal logs whenever we see a problem so if we see a problem setting up a hierarchy or we see a problem sending messages around the cluster then we should be writing messages into the error log telling you this check your channels all of this relies on being able to successfully send messages between two queue managers which means we have to have working channels between them


00:47:11
so make sure the channels are running make sure there aren't any errors on the channels to prevent you sending those messages also check your proxy subscriptions so we've talked about proxy subscriptions you should understand where they should exist and when they shouldn't exist you should be able to go in and check them you can go in and do display subscription subtype proxy and that will show you all the proxy subscriptions that a key manager knows about so I recommend you do that even on a running system so that you become aware of what they look like and where you expect to find check your Topic's status your topic status is showing you what the topic tree looks like from here you'll be able to see the resolved attributes for each node in the topic tree and you might be able to spot an inconsistency in your configuration perhaps where you've defined um something like clustering at one level but you've scoped your Publications down at another level and that's actually preventing Publications flowing between queue managers


00:48:14
watch for moving with messages between the queue mergers so it can be hard to work out exactly how far the messages have flowed whether it's got off of the first Q manager onto the second one or from there onto the next one so have a look at the stages of your channels look at where messages are flowed where messages might be built up so on that note your transmission cues look out for any human cues in your system where you're not expecting messages to be built up in the notes of these slides which you can download download from SlideShare you'll find details of the various system cues and which ones shouldn't have any messages built up on it in a in a healthy state and that brings me to the end so we've covered the basic topologies we've looked at what you can configure we've compared and contrasted them and then we finally looked at various scenarios which you have to apply them to so hopefully that gives you a good uh background into knowing how to set up an mq topology with published subscribe so thank you very much


00:49:24
foreign

