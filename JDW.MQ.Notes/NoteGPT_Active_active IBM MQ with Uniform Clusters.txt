
00:00:03
this video is going to introduce you to amuse uniform cluster capability this is a capability that builds on top of a number of existing mq features to build a truly active active in queue deployment giving you the ability to work by balanced your application instances across multiple running active queue managers distributing the messages and evenly distributing the workload from the point of view of those consuming those producing applications now it builds on a number of existing capabilities within mq & BQ clustering CCD T's can channel definition tables Auto reconnect all these features come together to give you one overall solution but it also brings in something extra this new uniform cluster capability so I'm going to take you through as an example a very very simple system to to make this clear to you the picture in the middle of your screen is depicting what we're going to do we have three queue managers commander one two and three and they're


00:01:03
configured into something called a uniform cluster so if we just look you can see we have three running queue managers now it's a simple bit of configuration to make these take them from being a standard MQ cluster which allows communication between them to being something called a uniform cluster in which case there's a lot more information sharing there's a lot more handshaking and a lot more cooperation between them or see how that benefits in just a minute then what we're going to do is we're going to have multiple instances of an application connecting it now this is all trying to achieve a always available active active solution which means I can't rely on one single running queue manager to provide all my availability or my scalability because at some point I'm going to have to restart those queue managers where is the maintenance or failures or whatever it happens to be and at that point my system becomes unavailable so really what I want to have is multiple active running systems distinct queue managers


00:02:04
which then give me a messaging capability but my applications can connect to unaware of the underlying multiple key managers that are actually providing the service likewise I can't rely on a single instance of an application for this to be a truly always available solution I have to have multiple instances of the application connecting in to provide that availability in the event of instances of the application fail where I want to scale past the capability of a single instance so what you're going to see is multiple instances of that same application connecting in and the uniform cluster brings a unique capability which is that ability to ensure that those instances are always evenly distributed across all those running queue managers and that's overcoming inconsistencies from workload balancing its overcoming inconsistencies from operations like stopping and restarting key managers changing a number of key managers you will see with all those things the uniform cluster


00:03:04
ensures that those instances of the application are evenly distributed and that's vitally important in messaging system because you want to make sure you're getting full capability from the underlying from time also you want to ensure that all the messages are being processed and because with this this is active active queue managers still individual messages are going to particular queue managers but you're being worked by balanced across them that's why you need your applications spread across all the queue managers in this cluster right so that's my background let's actually show through a demonstration I have a key merge is configured and what we're gonna do is we are going to kick off a number of instances of the application so that green box is representing the application I'm gonna kick off slightly more than that I'm going to kick off say 45 instances of our application what you're going to see in those three terminals at the bottom of the screen is you're gonna see an entry for each connection that comes in to each individual queue manager so they arranged underneath commander one two


00:04:05
and three now we're using a client channel definition table or CC TT to randomly distribute these connections across all three the koomer the applications itself don't need to know that there happens to be these three key managers under the cover they are just connecting to any qm which effectively is a queue manager group that says just connect me to one of them now when that happens it's quite a random process so sometimes you get an even distribution but more often not you get a slightly skewed distribution because it is just random so what we're gonna see is I'm going to see those entries come in across them and as predicted we sort of random distribution it's not particularly even but that's just down to chance what is happening at the moment now is both queue managers are actually talking amongst themselves because we're a uniform cluster and they are exchanging information about the various different running instances of application and here you just saw in the top right hand you saw an indication that a number of those connection we've gotten moved from one queue manager to another and in most


00:05:06
bottom terminals you can now see what we're an even distribution 15 connections across all three queue managers now despite that top right-hand terminal showing you that those reconnects for happening the applications themselves were completely unaware of that being the case those applications are using Auto reconnect with MQ which means under the covers through the application the application logic is just connecting and then you know producing and consuming messages but within the MQ layer it is saying I'm going to move that connection from being connected to kilo j3 to queue manager - and at that point it gets reconnected without the application seeing now obviously this will have some impact on the application from the point of view of Abel moved where they've connected to so it doesn't suit all application styles some applications are good with this from a point of view of they are written in a very stateless way and that I can connect to any those queue managers some applications are relying on all the messages going to one


00:06:07
location maybe that's for message ordering maybe that's because I'm looking for a particular message maybe a particular reply message and those scenarios you'd have to take more care over but in the case where the applications don't mind where they reconnect into you can see that they've been automatically rebalance with no impact to the application itself so that was nice it overcame the inconsistencies of just leaving it to chance as to how it distributed my applications what's possibly even nicer is if we say end one of those key metrics I'm going to end queue manager three more one over on the right now at that point those applications themselves or the MQ client detects fat and rebalances or reconnects those applications to a different key manager and as luck would have it it did it nice eat nice and evenly across those two queue managers and it's going to run like that continually while queue manager three is down because the uniform cluster knows what it just has those two queue managers running and that's where those those applications need to be distributed across the interesting one


00:07:09
is when I restart vacuum engine so for this scenario we've just applied maintenance we've automated our we bring the key manager backup a few seconds later and at that point without the uniform cluster the connections that we see in queue module one or two would just stay there because but the applications themselves have got no logic in to say you know reconnect when I see another queue manager become available and you know operationally you could go in and move some of those connections across but that's quite a lot of effort for you however with the uniform cluster in place I restart my queue manager at which point here we see the other commands detect it and they move some of those connections across and you can see that it's moved a good proportion of those applications across and now it's just done the last little bit of rebalancing or it's almost level and then it'll just fine-tune it over time to always make sure that we've got a nice even distribution so that shows that with the uniform cluster in place I don't have to worry from an Operations


00:08:09
point of view or from an application point of view pinning myself to individual accumulations to ensure that I've got an even distribution or overcoming those operational tasks like restarting key managers or recovering from failures which means I can really start to build an application which is decoupled from the underlying fact that I happen to have multiple key managers running I really can't just connect to a group and just leave the vmq uniform cluster to do the hard work under the covers so that was running with three key villagers it's also another scenario because saying we're doing this both for availability but we're also doing it for horizontal scaling we might go to a point where we want to bring in a fourth key manager now if we bring in a fourth queue manager normally I would have to bring in a 4q manager I'd have to configure it to be the same as the other Q manages to find all the different resources make sure they they lined up and then start to move my applications across now this is where I'm going to show you another new capability this is just coming out in mq-9 one for which is the ability to


00:09:13
make that configuration of these multiple QH is much more consistent or easier to make consistent so I have a script called add cue manager for now I've just done this because it makes it much easier than me trying to type it and remember exactly what I need to do and it's quite a simple script and we'll go through it one step at a time you'll just see what we're doing so first thing we're going to do is we're going to create a key manager so we're going to create cue manager for now that if you look in the top left-hand screen then you can see we've got a standard create MQM command as we always use with mq there's a difference here though it's got some extra attributes to it which you might have seen before and this is because in nine month all you now have the ability to be able to say when you create a queue manager whenever I start with queue manager I want to pull in definitions from predetermined locations or predetermined files and I've configured this to say when I start a queue manager I want to pull in a set of any file definitions and also on a


00:10:14
pulling in a set of mvrc commands and that's the PI attribute and the IC attribute I've also got and I actually because I want to pull in a say a common set of commands which I want to use but all of my key managers and this is exactly how I configured key managers one two and three when I serve this demo out I want to make sure that I can use the same script and then key there's some things but you need to have specific to the environment of particular key manager so for example the connection name of your channels your cluster receive a channel for example you need to be able to have that unique for each queue manager so with that the con name for that so you can pass that in there's an environment and that then gets embedded into the commands that we've defined so what I'm going to do on the undo that and that's going to create vacuum manager form so that's creative a key manager I haven't started it yet what I need to do before the applications start being distributed across queue manager for as well I need to update the CCD T this client channel definition


00:11:16
table it's a just a JSON file which defines how do I get to queue managers one two three and now four so I'm gonna I've got a new version of our which happens to have the entry for four kimura four in so I'm going to replace the existing one with that later one so this is actually being pulled in dynamically by the application so the applications were just configured to use for CCGT when they connect if they get told to reconnect they will also dynamically pulling their CC duty I don't have to restart the applications to start using this particular JSON file so I've done that now what I'm going to do is I'm going to make a bit of make a bit of space on my screen I'm going to move these terminals along for queue managers one two or three and then I'm going to start up a new one the queue manager for so here we go on the far edge of the screen we've got queue manager for listening and it's obviously got no connections because my commander is not running so now I'm going to start up a queue manager we start the queue manager and at this point because it been configured the same has been added into the uniform


00:12:17
cluster you can see almost immediately some of the connections get moved across and as time will go on more of those connections will get distributed here we see and to the point where we are fair to be at the even distribution of our connections across all four so hopefully that demonstrates how I can take a set of key managers I can perform operations on them I can extend for set of them in this uniform cluster and the applications who are just simply connecting to the group of queue managers rather than a specific one all get managed by MQ itself they don't have to know that this is going on they don't have to see that this is going on is it all being done outside and unaware of the application layer so I can start to really build very very highly available active ActiveMQ solutions which I can horizontally scale without the applications needing to worry about that that's all being taken care for it okay bye MQ so with that I'll stop and I hope you go and follow the links that I put in this video so that you can actually read


00:13:20
up more on the concept of uniform class

