Today I’m at Lake Crabtree, one of my favorite places to cycle out to. As beautiful as it is, the lake is artificial. It’s a carefully manufactured solution to address potential problems related to flooding. And you know another carefully manufactured solution to address problems before they occur? Why, DevOps of course! I’m gonna keep finding a way to segue from park to video topic, I tell you! DevOps is what you form when you break down the barriers that traditionally separate developers (“Dev”) from IT operations (“Ops”). When these teams work in isolation from one another, the lack of communication and coordination between them can lead to all sorts of problems, inefficiencies, and delays. Often the people who are writing code are out of sync with the people who deploy and manage it. And that’s where DevOps comes in, by integrating various tools and solutions to eliminate manual steps. This integration helps to improve visibility and efficiency, and emphasizes agility, meaning the ability to implement changes easily. We’re going to focus initially on the first part of DevOps: application development. A huge amount of value can be gained with efficiencies in the process by which you write, test, and deploy application code. You’ll want to start with a modern source code manager like Git. From there you build on this foundation with a modern integrated development environment like Microsoft VSCode or IBM Developer for z/OS. And pull it all together with automated build, test, and possibly even deployment. Source code managers (or SCMs) support parallel development where each developer can easily maintain their own code streams and merge their code when it is ready to be promoted to the next phase. SCMs also provide backup and version control of source code, which creates a safety net if something goes wrong. The de facto standard for SCMs these days is Git; it is commonly used for cloud-native development and can be used equally for developing code on IBM Z. Git is fully capable of version-controlling Assembler, COBOL, JCL, or PL/1 as it is any other language. Git can easily be integrated with z/OS using a client provided by Rocket Software which makes it easy to include Git-based Continuous Integration and Continuous Delivery pipelines on z/OS. SCMs overcome many of the issues of more traditional Library Managers. Library managers work well for applications tested and deployed in a waterfall process because their stages are tied to each environment between development and production.  However, they do not handle agile development as well. Instead of having a code branch representing a particular environment like “production” or “acceptance test”, modern SCMs use each branch for a particular feature or deliverable. This means that you can merge the branches together in different ways according to which features you need in a particular environment, and meanwhile each branch in the SCM can be updated independently of the others. This process can be extended to include automation scripts and any other text files that are part of coding, building, or deploying an application. Having everything that you need in the same SCM enables Continuous Integration and Continuous Delivery pipelines to include automated building, deploying, and testing for application changes. IDEs are the digital home of your development teams. These suites of integrated tools allow developers to check out source code from an SCM, edit, and even run and debug their code in an intuitive experience. The goal is to enable developers to write code in parallel, receive rapid feedback on their work, deliver updates continuously, and maintain stable deployment environments. IDE’s provide a rich experience for writing and debugging source code. For example features like syntax highlighting, unreachable code detection, hints to find how a variable was defined, runtime debugging with breakpoints and variable tracing. IDE’s built for use with source code on z/OS typically support COBOL, Assembler, PL/1, and JCL. There are IDE’s built specifically for use with z/OS, like IBM Developer for z/OS. This IDE is Microsoft VSCode, a popular IDE that is built on open source. Here we’re showing some COBOL code in VS Code. We can vastly improve this by adding the IBM Z Open Editor extension. It provides support for IBM Enterprise COBOL, PL/I, and JCL, including syntax highlighting, real-time error checking, and code completion. This is a really great option for developers who are working across platforms and are familiar with VS Code from their projects on other non-Z platforms. There’s also IBM Developer for z/OS (or IDz). It’s considered the premier IDE for z/OS. In addition to providing COBOL, PL/I, Java, and C/C++ support, IDz includes a fully integrated debugger. IDz also provides the flexibility of editing style for new mainframe developers who might prefer graphical flare, and experienced z/OS professionals who prefer command style. Finally, let’s touch quickly on IBM Application Discovery and Delivery Intelligence (or ADDI). IBM ADDI analyzes applications that are designed for IBM Z to quickly discover interdependencies. It breaks down a complex application into its various pieces and represents the pieces in a way that is approachable for developers. Developers can then easily see where changes must be made in the source code, and the effects those changes will have on other areas of the application. This is a callgraph generated by ADDI of a sample COBOL application. The graph shows individual COBOL modules and their relationship to each other (which one calls which one), and changes they make to databases and data files. From here we can understand how changes in one module may impact another module. So that’s a look at DevOps. DevOps teams focus on standardizing development environments and automating delivery processes. While integrating IBM Z into your hybrid cloud, it is imperative that developers and IT operations understand that the same agile processes can be performed on IBM Z as on other platforms, by using the same DevOps tools those platforms use. Coming up in the next video we’re going to look at common tooling across environments.