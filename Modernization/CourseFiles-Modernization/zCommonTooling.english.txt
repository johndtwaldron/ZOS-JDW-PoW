When you’re learning something new, it’s helpful if you can do so using stuff you’re already familiar with. Take this frisbee for example. If I already know how to throw it, I can apply that knowledge to something different. Like disc golf [throw]. The frisbee is a common tool. Consistent tooling across environments means your teams can utilize shared skills and expand the number of people who can potentially work in an environment. Historically, teams working in one environment are unfamiliar with the tools used in other environments and vice versa. By using universal tools regardless of hardware platform, all teams become familiar with the same tools and have the potential to work in any environment. And common tooling here refers not just to uniformity of tools between teams but commonality to the tools people are using outside of your enterprise. How many people list the tools you use in their LinkedIn profile? Are these tools part of a school curriculum? Using industry standard tooling positions you at an even better advantage due to the immediate increase in productivity from new hires that join your ranks. All these factors are beneficial to your team’s velocity. A good example of this is Microsoft VSCode, which students commonly use for writing Python code in university. As we saw in the last module VSCode can also be used for coding in COBOL with a free extension called the IBM Z Open Editor. So even if your university grads haven’t learned a whole lot of COBOL yet, they’ll be happy to learn that they can code it in an environment familiar to them. Common tools also allow for sharing digital artifacts across environments. For example, a common DevOps toolchain allows for the definition of one pipeline that performs some operations on IBM Z, to deploy the backend, and some operations on public cloud to deploy the frontend, with a centralized dashboard for reporting. In a general sense, you might be able to share scripts or common routines across environments, increasing shared skills and knowledge amongst teams and in effect boosting productivity. Let’s look at another example with Jenkins. Jenkins organizes and schedules when automation must be performed. Automated CI/CD pipelines using Jenkins can build, test, and deploy front-end code to a public cloud and back-end code to z/OS. In this case, z/OS becomes “just another step” in your pipeline. Ansible is an automation engine that automates provisioning, configuration management, application deployment, and many other IT requirements. Ansible uses a simple, English-like, widely used Open Source language that is called YAML for playbooks that automate application and IT infrastructure. You can build automation using Ansible where some stuff resides on Linux and other stuff on z/OS, all with the same Open Source tool. Ansible Core Collection for z/OS - part of a broader offering known as Red Hat Ansible Certified Content for IBM Z - provides a library of common functions for working with z/OS. And those are just some examples. The key takeaway here is working with IBM Z need not be much different from all the other platforms you’re already interacting with. In the next video we’ll turn our attention to REST enablement.